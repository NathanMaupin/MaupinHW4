# -*- coding: utf-8 -*-
"""
Created on Fri Nov 12 18:10:43 2021

@author: Nathan Maupin
"""

# 1.  Numerical Differentiation (20 pts) Code.

import numpy as np
import math
import matplotlib.pyplot as plt
import pandas as pd


h = 1e-8
f_array = []
E = []
N = np.arange(0, 4, 0.04)

def f(x): 
    return math.sin(x)

def fprime(x):
    return math.cos(x)

def fiveend(x):
    return 1/(12*h)*(-25*f(x) + 48*f((x+h)) - 36*f(x+2*h) + 16*f(x+3*h) - 3*f(x+4*h)) 

def fivemid(x):
    return 1/(12*h)*(f(x-2*h)-8*f(x-h)+8*f(x+h)-f(x+2*h))   

#print("***Problem 1***")
for count, n in enumerate(N):
    # if statements check for which 5-point has less absolute error
    if abs(fprime(n)-fivemid(n)) < abs(fprime(n)-fiveend(n)):

        E.append(abs(fprime(n)-fivemid(n)))
    else:

        E.append(abs(fprime(n)-fiveend(n)))
        
plt.plot(N, E)
plt.title("Problem 1 Absolute Error")
plt.show()



h = math.pi/8
E_forward = []
E_center = []
E_backward = []


# Part a
def f(x):
    return x + math.sin(x)

def fprime(x):
    return -1*math.sin(x)

def backward32(x):
    return 1/h**2*(f(x-2*h) - 2*f(x-h) + f(x))

def center32(x):
    return 1/h**2*(f(x-h) - 2*f(x) + f(x+h))

def forward32(x):
    return 1/h**2*(f(x) - 2*f(x+h) + f(x+2*h))

setup = {"derivative": ["f'' exact", "f'' forward", "f'' centered", "f'' backward"],
         "values": [str(fprime(1)), str(forward32(1)), str(center32(1)), 
                    backward32(1)]}
table = pd.DataFrame(setup, columns = ['derivative', 'values'])
print("***Problem 4***")
print(table)

# Part b
N = np.arange(-0.5, 0.5, 0.001)
for count, n in enumerate(N):
    E_forward.append(abs(fprime(n)-forward32(n)))
    E_center.append(abs(fprime(n)-center32(n)))
    E_backward.append(abs(fprime(n)-backward32(n)))
   
plt.plot(N, E_forward, label="Forward")
plt.plot(N, E_center, label="Center")
plt.plot(N, E_backward, label="backward")
plt.title("Problem 4 Absolute Error")
plt.legend()
plt.show()

print("\n***Problem 5***")
h = 5
t = [0, 5, 10, 15, 20, 25]
T = [80, 44.5, 30, 24.1, 21.7, 20.7]
g = []


def forward1(T1, T2, T3):
    return (1/(2*h))*(-3*T1 + 4*T2 - T3)

def center1(T1, T2):
    return (1/(2*h))*(T1 - T2)

def backward1(T1,T2, T3):
    return (1/(2*h))*(T1 - 4*T2 + 3*T3)

for i, j in enumerate(T):
    check = False
    
    if i >= 1 and i <= 4 and check == False:
        check = True
        g.append(center1(T[i+1], T[i-1]))
    if i <= 3 and check == False:
        check = True
        g.append(forward1(T[i], T[i+1], T[i+2]))
    if i >= 2 and check == False:
        check = True
        g.append(backward1(T[i-2], T[i-1], T[i])
                        )
setup = {"Time (sec)":[t[0], t[1], t[2], t[3], t[4], t[5]], 
         "Gradient": [g[0], g[1], g[2], g[3], g[4], g[5]]}
grad_table = pd.DataFrame(setup, columns = ['Time (sec)', 'Gradient'])
print(grad_table)
